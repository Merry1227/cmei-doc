#Linux 进程内存

##理论基础

from <http://blog.csdn.net/zhh_steven/article/details/18734705>

虚拟内存管理：

操作系统一般采用虚拟内存管理技术（简单讲分层内存换来技术，cpu要操作某个数据的过程：首先在cache中查询，若无在内存中查询，若无在硬盘中查询；具体内容请参考其他文档）；
http://www.cnblogs.com/CareySon/archive/2012/04/25/2470063.html
 
内核空间和用户空间：
所以os分配给每个进程一个独立的，连续的，虚拟的，地址内存空间，该大小一般是4G（32位操作系统，即2的32次方），其中将高地址值的内存空间分配给os占用，linux os占用1G，window os占用2G；其余内存地址空间分配给进程使用；
分别称作内核空间和用户空间；
通常情况下，用户进程不能访问内核空间的地址，例外情况是用户进程通过系统调用访问内核空间；
 
用户空间布局：
用户空间被分成几个段(Segment)， 从高地址到低地址分别为：Stack, Heap, BSS, Data, Text;
Text segment:    编译后的代码段
Ro-data segment: 只读数据段（如字符串常量）
Data Segment：initialized global and static data
BSS Segment： uninitialized global and static data
Heap Segment： dynamically allocated withnew|delete|malloc|free
StackSegment:    local variables
 
More on <http://blog.csdn.net/duyiwuer2009/article/details/7994091>
 
##Linux进程信息查看分析

<http://www.cnblogs.com/eustoma/archive/2012/04/27/2473175.html>

**jps, top, pstack [pid] |grep 'allocate'**

cat /proc/pid/status  
  
* Name:   rsyslogd  
* State:  S (sleeping)　　进程状态 R (running)", "S (sleeping)", "D (disk sleep)", "T (stopped)", "T(tracing stop)", "Z (zombie)", or "X (dead)"
* Tgid:   987                  Tgid是线程组的ID,一个线程一定属于一个线程组(进程组).
* Pid:    987                   这个是进程的ID,更准确的说应该是线程的ID,ps命令的LWP列输出,PID一列其实是进程组,而LWP是轻量级进程,也就是线程,因为所有的进程必须一个线程,那就是它自己.
* PPid:   1                      当前进程的父进程  
* TracerPid:      0            跟踪当前进程的进程ID,如果是0,表示没有跟踪.  
Uid:    0       0       0       0  
Gid:    0       0       0       0  
第一列数字(RUID):实际用户ID,指的是进程执行者是谁.  
第二列数字(EUID):有效用户ID,指进程执行时对文件的访问权限.  
第三列数字(SUID):保存设置用户ID,作为effective user ID的副  本,在执行exec调用时后能重新恢复原来的effectiv user ID.  
第四列数字(FSUID):目前进程的文件系统的用户识别码.一般情况下,文件系统的用户识别码(fsuid)与有效的用户识别码(euid)是相同的.

* Utrace: 0
* FDSize: 32 FDSize是当前分配的文件描述符,这个值不是当前进程使用文件描述符的上限.
* Groups:     这里的groups表示启动这个进程的用户所在的组.
* VmPeak:    36528 kB     当前进程运行过程中占用内存的峰值.
* VmSize:    36528 kB 进程现在正在占用的内存 ，基本对应top 里面VIRT
* VmLck:         0 kB     代表进程已经锁住的物理内存的大小.锁住的物理内存不能交换到硬盘.
* VmHWM:      1432 kB 程序得到分配到物理内存的峰值.
* VmRSS:      1420 kB 程序现在使用的物理内存
* VmData:    33980 kB 表示进程数据段的大小.
* VmStk:        88 kB 表示进程堆栈段的大小
* VmExe:       320 kB 表示进程代码的大小
* VmLib:      2044 kB 表示进程所使用LIB库的大小
* VmPTE:        56 kB 占用的页表的大小.
* VmSwap:        0 kB 进程占用Swap的大小
* Threads:        3   表示当前进程组有3个线程.
* SigQ:   1/7954 表示当前待处理信号的个数
* SigPnd: 0000000000000000 屏蔽位,存储了该线程的待处理信号,等同于线程的PENDING信号.
* ShdPnd: 0000000000000000 屏蔽位,存储了该线程组的待处理信号.等同于进程组的PENDING信号.
* SigBlk: 0000000000000000 存放被阻塞的信号,等同于BLOCKED信号.
* SigIgn: 0000000001001206 存放被忽略的信号,等同于IGNORED信号.
* SigCgt: 0000000180014c21 存放捕获的信号,等同于CAUGHT信号
* CapInh: 0000000000000000 表示能够被当前进程执行的程序继承的能力.
* CapPrm: ffffffffffffffff 表示进程能够使用的能力,在* cap_permitted中可以包含cap_effective中没有的能力，这些能力是被进程自己临时放弃的,也可以说cap_effective是cap_permitted的一个子集.
* CapEff: ffffffffffffffff 当一个进程要进行某个特权操作时,操作系统会检查cap_effective的对应位是否有效,而不再是检查进程的有效UID是否为0.
* CapBnd: ffffffffffffffff  是系统的边界能力,我们无法改变它.
* Cpus_allowed:   3   指出该进程可以使用CPU的亲和性掩码,因为我们指定为两块CPU,所以这里就是3,如果该进程指定为4个CPU(如果有话),这里就是F(1111).
* Cpus_allowed_list:      0-1  指出该进程可以使用CPU的列表,这里是0-1.
* Mems_allowed:   1
* Mems_allowed_list:      0 内存同CPU一样,进程rsyslogd只是使用了结点0的内存资源.
* voluntary_ctxt_switches:        1 表示进程主动切换的次数
* nonvoluntary_ctxt_switches:     0 表示进程被动切换的次数.

##JAVA进程内存分配

<http://java-mzd.iteye.com/blog/848635>

<http://www.cnblogs.com/gw811/archive/2012/10/18/2730117.html>

<http://segmentfault.com/a/1190000002931555>

###查看Java 内存

<http://my.oschina.net/u/1385143/blog/176554>

**jps,jinfo,jstat,jconsole,jmap,jstack**

jmap -heap pid

##Java 内存与进程内存关系

<http://www.tuicool.com/articles/3auUJj>

当java heap发生变化时，对于进程中VmData, VmRSS, VMStack 可能发生变化。

 